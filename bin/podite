#!/usr/bin/perl

use Mojo::Base -strict;

use Mojolicious::Plugin::FeedReader;
use Mojo::URL;
use lib 'lib';
use Mojo::JSON qw(encode_json decode_json);
use Mojo::File 'path';
use Mojo::Util 'dumper', 'encode';
use Text::Wrap 'wrap';
use Fcntl qw(:flock O_RDWR O_CREAT);
use App::podite::URLQueue;
use File::stat;

my $download_dir = path("$ENV{HOME}/Podcasts")->make_path;

my $ua = Mojo::UserAgent->new( max_redirects => 5 );
$ua->proxy->detect;

my $share_dir  = path("$ENV{HOME}/.local/share/podite/")->make_path;
my $state_file = $share_dir->child('state');
my $cache_dir  = $share_dir->child('cache')->make_path;

my ( $fh, $state ) = read_state();

my $mode = shift || 'check';

my %modes = (
    subscribe   => \&subscribe,
    unsubscribe => \&unsubscribe,
    check       => \&check,
);

if ( $modes{$mode} ) {
    $modes{$mode}->(@ARGV);
}

write_state( $fh, $state );

exit 0;

sub check {
    update();
    my @names  = sort keys %{ $state->{subscriptions} };
    my $reader = Mojolicious::Plugin::FeedReader->new;
    my @download_items;
  Feed:
    for my $name (@names) {
        my $feed  = $reader->parse_rss( $cache_dir->child($name) );
        my @items = @{ $feed->{items} };
      Item:
        while ( my $item = shift @items ) {
            my $decision =
              $state->{subscriptions}->{$name}->{items}->{ $item->{guid} }
              || '';
            if ( $decision eq 'downloaded' or $decision eq 'hidden' ) {
                next;
            }

            ## TODO provide that in Mojo::Feed
            $item->{feed_name} = $name;

            print encode( 'UTF-8', $item->{title} ), "\n";
            ## TODO write actual renderer
            ## TODO trim whitespace, see gameshow action castle
            ## TODO shorten
            print encode( 'UTF-8',
                wrap( '', '', Mojo::DOM->new( $item->{content} )->all_text ) ),
              "\n";
            while (1) {
                print "Download this item [y,n,N,s,S,q,?]? ";
                my $key = <STDIN>;
                chomp($key);
                if ( $key eq 'y' ) {
                    push @download_items, $item;
                    next Item;
                }
                elsif ( $key eq 'n' ) {
                    $state->{subscriptions}->{$name}->{items}->{ $item->{guid} }
                      = 'hidden';
                    next Item;
                }
                elsif ( $key eq 'N' ) {
                    for ( $item, @items ) {
                        $state->{subscriptions}->{$name}->{items}
                          ->{ $item->{guid} } = 'hidden';
                    }
                    next Feed;
                }
                elsif ( $key eq 'S' ) {
                    next Feed;
                }
                elsif ( $key eq 'q' ) {
                    last Feed;
                }
                elsif ( $key eq 's' ) {
                    next Item;
                }
                else {
                    print "y - download this item\n"
                      . "n - do not download this item, never ask again\n"
                      . "N - do not download this item or any of the remaining ones\n"
                      . "s - skip this item, ask next time\n"
                      . "S - skip this feed, ask next time\n"
                      . "q - quit, do not download this item or any other\n";
                    next;
                }
            }
        }
    }

    my $q = App::podite::URLQueue->new( ua => $ua );
    for my $item (@download_items) {
        my $feed_name = $item->{feed_name};
        my $url       = Mojo::URL->new( $item->{enclosures}->[0]->{url} );
        my $file =
          $download_dir->child($feed_name)->child( $url->path->parts->[-1] );
        $file->dirname->make_path;
        say "$url -> $file";
        $q->add(
            $url => sub {
                my ( $ua, $tx ) = @_;
                $tx->result->content->asset->move_to($file);
                $state->{subscriptions}->{$feed_name}->{items}
                  ->{ $item->{guid} } = 'downloaded';
                warn "Download $file finished\n";
            }
        );
    }
    $q->wait;
    return;
}

sub update {
    my (@names) = @_;
    if ( !@names ) {
        @names = sort keys %{ $state->{subscriptions} };
    }
    my $q = App::podite::URLQueue->new( ua => $ua );
  Feed:
    for my $name (@names) {
        my $feed = $state->{subscriptions}->{$name};
        if ( !$feed ) {
            warn "Unknown feed $name.\n";
            next Feed;
        }
        my $url        = $feed->{url};
        my $cache_file = $cache_dir->child($name);
        my $tx         = $ua->build_tx( GET => $url );
        if ( -e $cache_file ) {
            my $date = Mojo::Date->new( stat($cache_file)->mtime );
            $tx->req->headers->if_modified_since($date);
        }
        warn "Updating $name.\n";

        $q->add(
            $tx => sub {
                my ( $ua, $tx ) = @_;
                my $res = $tx->result;
                warn "Fetched $name with rc " . $res->code . "\n";
                if ( $res->is_error ) { say $res->message; return; }
                if ( $res->code eq 200 ) {
                    open( my $fh, '>', $cache_file )
                      or die "Can't open cache file $cache_file: $!\n";
                    print $fh $res->body;
                }
            }
        );

    }
    $q->wait;
    return;
}

sub unsubscribe {
    my ($name) = @_;
    delete $state->{subscriptions}->{$name};
    my $cache_file = $cache_dir->child($name);
    if ( -e $cache_file ) {
        unlink $cache_file or warn "Can't delete $cache_file: $!\n";
    }
    return;
}

sub subscribe {
    my ( $name, $url ) = @_;
    $state->{subscriptions}->{$name}->{url} = $url;
    return;
}

sub write_state {
    my ( $fh, $state ) = @_;
    seek $fh, 0, 0;
    truncate $fh, 0;
    print {$fh} encode_json($state);
    return;
}

sub read_state {
    sysopen(my $fh, $state_file, O_RDWR|O_CREAT)
      or die "Can't open state file $state_file: $!\n";
    flock( $fh, LOCK_EX | LOCK_NB ) or die "Cannot lock $state_file: $!\n";
    my $content = do { local ($/); <$fh> };
    my $json = decode_json( $content || '{}' );
    return ( $fh, $json );
}
