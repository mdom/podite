#!/usr/bin/perl

use Mojo::Base -strict;

use Mojolicious::Plugin::FeedReader;
use Mojo::URL;
use lib 'lib';
use Mojo::JSON qw(encode_json decode_json);
use Mojo::File 'path';
use Mojo::Util 'dumper', 'encode';
use Text::Wrap 'wrap';

my $download_dir = path("$ENV{HOME}/Podcasts")->make_path;

my $ua = Mojo::UserAgent->new( max_redirects => 5 );
$ua->proxy->detect;

my $share_dir = path("$ENV{HOME}/.local/share/ppod/")->make_path;

my $state_file = $share_dir->child('state');

my $cache_dir = $share_dir->child('cache')->make_path;

my $mode = shift;

my %modes = (
    subscribe   => \&subscribe,
    unsubscribe => \&unsubscribe,
    check       => \&check,
);

my $state = read_state();

if ( $modes{$mode} ) {
    $modes{$mode}->(@ARGV);
}

write_state($state);

exit 0;

sub check {
    update();
    my @names  = sort keys %{ $state->{subscriptions} };
    my $reader = Mojolicious::Plugin::FeedReader->new;
    my @items;
  Feed:
    for my $name (@names) {
        my $feed = $reader->parse_rss( $cache_dir->child($name) );
      Item:
        for my $item ( @{ $feed->{items} } ) {
            if ( $state->{subscriptions}->{$name}->{items}->{ $item->{guid} } )
            {
                next;
            }
            print encode('UTF-8', $item->{title}), "\n";
            print encode('UTF-8', wrap( '', '', Mojo::DOM->new( $item->{content} )->all_text )),

            ## TODO provide that in Mojo::Feed
            $item->{feed_name} = $name;

              "\n";
            while (1) {
                print "Download this item [y,n,s,q,?]? ";
                my $key = <STDIN>;
                chomp($key);
                if ( $key eq 'y' ) {
                    push @items, [ $name, $item ];
                    next Item;
                }
                elsif ( $key eq 'n' ) {
                    $state->{subscriptions}->{$name}->{items}->{ $item->{guid} }
                      = 'ignored';
                    next Item;
                }
                elsif ( $key eq 'q' ) {
                    last Feed;
                }
                else {
                    print "y - download this item\n"
                      . "n - do not download this item\n"
                      . "s - leave this item undecided\n"
                      . "q - quit, do not download this item or any other\n";
                    next;
                }
            }
        }
    }
        my $url = Mojo::URL->new( $item->{enclosures}->[0]->{url} );
    for my $item (@items) {
        my $feed_name = $item->{feed_name};
        my $file =
          $download_dir->child($feed_name)->child( $url->path->parts->[-1] );
        $file->dirname->make_path;
        say "$url -> $file";
        my $tx = $ua->get($url);
        $tx->result->content->asset->move_to($file);
        $state->{subscriptions}->{$name}->{items}->{ $item->{guid} } =
          'downloaded';
    }
}

sub update {
    my (@names) = @_;
    if ( !@names ) {
        @names = sort keys %{ $state->{subscriptions} };
    }
  Feed:
    for my $name (@names) {
        my $feed = $state->{subscriptions}->{$name};
        if ( !$feed ) {
            warn "Unknown feed $name.\n";
            next Feed;
        }
        my $url = $feed->{url};
        warn "Updating $name.\n";
        my $res = Mojo::UserAgent->new->get($url)->result;
        if ( $res->is_error ) { say $res->message; next; }

        open( my $fh, '>', $cache_dir->child($name) )
          or die "Can't open cache file: $!\n";
        print $fh $res->body;
    }
    return;
}

sub unsubscribe {
    my ($name) = @_;
    delete $state->{subscriptions}->{$name};
    my $cache_file = $cache_dir->child($name);
    if ( -e $cache_file ) {
        unlink $cache_file or warn "Can't delete $cache_file: $!\n";
    }
    return;
}

sub subscribe {
    my ( $name, $url ) = @_;
    $state->{subscriptions}->{$name}->{url} = $url;
    return;
}

sub write_state {
    my ($json) = @_;
    open( my $fh, '>', $state_file )
      or die "Can't open state file $state_file: $!\n";
    print {$fh} encode_json($json);
    return;
}

sub read_state {
    if ( !-e $state_file ) {
        return {};
    }
    open( my $fh, '<', $state_file )
      or die "Can't open state file $state_file: $!\n";
    my $content = do { local ($/); <$fh> };
    my $json = decode_json($content);
    return $json;
}
